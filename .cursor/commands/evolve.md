# /evolve 命令

用开发过程中的新发现、变更或改进来更新现有规格。保持文档与实际同步。

---

## 角色定义

**文档演进代理：** 用新发现和变更更新现有规格，同时保留上下文并维护变更日志。

**推荐 Cursor 模式：** Plan

---

## 使用方法

```
/evolve [task-id] [变更描述]
```

**示例：**
- `/evolve user-auth 安全评审后增加了密码强度验证`
- `/evolve checkout-flow 发现需要游客结算回退方案`
- `/evolve notification-system 基于性能测试从轮询改为 WebSocket`

---

## 执行流程

### 阶段 1：分析

1. **查找现有规格** - 在 `./docs/specs/active/[task-id]/` 中检查 feature-brief.md, spec.md, plan.md, tasks.md
2. **阅读所有相关文件** - 理解当前状态和上下文
3. **分类变更**：发现/改进（低）、新增/修改（中）、移除/架构（高）
4. **评估升级需求**：多个重大变更 → 建议 `/upgrade`，简单发现 → 继续 `/evolve`

### 阶段 2：规划

展示演进计划，包含：
- Task ID 和要更新的文件
- 变更摘要、类型和影响等级
- 相关章节的修改前后对比
- 建议的变更日志条目
- 建议（继续或建议升级）

**等待用户确认后再继续。**

### 阶段 3：执行

1. **更新规格文件** - 保留上下文，添加变更日志，递增版本，更新日期
2. **添加变更日志条目** - feature-brief.md 使用"变更日志"表，spec.md 使用"修订历史"表
3. **记录交叉引用** - 如果变更影响其他文档
4. **更新状态** - 如果规格之前标记为"完成"

### 阶段 4：验证

最终输出前验证：
- 规格文件已更新，变更日志已添加，版本已递增
- 上下文已保留，交叉引用已记录
- **回读文件确认变更已应用**

---

## 输出格式

以此结尾：

```
✅ 规格已演进: `./docs/specs/active/[task-id]/[file]`

**变更:** [类型] | 影响: [等级] | 版本: [旧] → [新]
**变更日志:** | [版本] | [日期] | [描述] | [原因] |
**交叉引用:** [可能需要更新的其他文件]
**下一步:** 评审规格，如需要更新相关文档，或对重大变更考虑 `/upgrade`
```

---

## 变更类型

- **发现**（低）：小发现 → 添加到约束
- **改进**（低）：澄清需求 → 更新具体细节
- **新增**（中）：新需求 → 添加，标注为初始规格后新增
- **修改**（中）：方案变更 → 更新，记录理由
- **移除**（高）：范围缩减 → 移至不在范围内，记录原因

---

## 何时建议升级

当变更从根本上改变方案、需要多个相关变更、brief 不够用、或架构需要重新设计时，建议使用 `/upgrade`。

---

## 常见问题

- **多个规格文件**：询问要更新哪个
- **变更冲突**：指出矛盾并询问是否都需要更新
- **缺少变更日志**：为旧规格添加变更日志章节

---

## 相关命令

- `/brief [task-id]` - 创建初始简报
- `/upgrade [task-id]` - 扩展到完整 SDD 4.0
- `/refine [task-id]` - 交互式改进会话
- `/specify [task-id]` - 创建/更新详细规格
- `/plan [task-id]` - 更新技术方案
