# 常见架构模式

调研期间模式选择的参考指南。

## 结构模式

### 仓储模式 (Repository Pattern)
**何时使用**: 需要数据访问抽象
**结构**: 接口定义 CRUD 操作，实现处理持久化
**优点**: 可测试性，可切换数据源
**示例**:
```typescript
interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<User>;
}
```

### 服务层模式 (Service Layer Pattern)
**何时使用**: 跨多个实体的复杂业务逻辑
**结构**: 服务编排操作，仓储处理持久化
**优点**: 关注点分离，可复用业务逻辑

### 工厂模式 (Factory Pattern)
**何时使用**: 复杂对象创建，多种变体
**结构**: 工厂方法/类创建实例
**优点**: 封装创建逻辑，灵活实例化

### 策略模式 (Strategy Pattern)
**何时使用**: 同一操作的多种算法
**结构**: 接口定义操作，实现变化行为
**优点**: 运行时算法选择，开闭原则

## API 模式

### REST
**何时使用**: 标准 CRUD 操作，面向资源
**特点**: HTTP 方法，无状态，可缓存
**最适合**: 公共 API，简单操作

### GraphQL
**何时使用**: 复杂查询，移动客户端，多个消费者
**特点**: 单一端点，客户端指定数据
**最适合**: 灵活的数据需求，减少过度获取

### RPC (gRPC, tRPC)
**何时使用**: 内部服务，需要高性能
**特点**: 基于方法，类型化契约
**最适合**: 微服务，实时通信

## 数据模式

### 事件溯源 (Event Sourcing)
**何时使用**: 需要审计跟踪，复杂状态重建
**结构**: 存储事件，从事件流派生状态
**权衡**: 复杂度 vs 可审计性

### CQRS
**何时使用**: 读/写模式差异显著
**结构**: 分离读写模型
**权衡**: 复杂度 vs 优化

### 工作单元 (Unit of Work)
**何时使用**: 多个数据库操作需要原子性
**结构**: 跟踪变更，作为单一事务提交
**优点**: 一致性，回滚能力

## 前端模式

### 容器/展示组件 (Container/Presenter)
**何时使用**: 分离逻辑和展示
**结构**: 容器处理状态/逻辑，展示组件处理 UI
**优点**: 可测试性，可复用性

### 复合组件 (Compound Components)
**何时使用**: 共享状态的相关组件
**结构**: 父组件提供 context，子组件消费
**优点**: 灵活组合，隐式状态共享

### Render Props / Hooks
**何时使用**: 组件间共享有状态逻辑
**结构**: 函数通过 props 或 hook 接收状态/处理器
**优点**: 可复用性，组合

## 集成模式

### 断路器 (Circuit Breaker)
**何时使用**: 防止级联故障
**结构**: 监控失败，超过阈值时打开断路器
**优点**: 韧性，优雅降级

### 带退避的重试 (Retry with Backoff)
**何时使用**: 预期会有临时性故障
**结构**: 以递增延迟重试
**优点**: 韧性，问题期间减少负载

### 消息队列 (Message Queue)
**何时使用**: 异步处理，解耦生产者/消费者
**结构**: 生产者 → 队列 → 消费者
**优点**: 可扩展性，可靠性，解耦

## 选择标准

| 模式 | 复杂度 | 可测试性 | 可扩展性 | 使用场景 |
|------|--------|----------|----------|----------|
| 仓储 | 低 | 高 | 中 | 数据访问 |
| 服务层 | 中 | 高 | 中 | 业务逻辑 |
| 事件溯源 | 高 | 中 | 高 | 审计需求 |
| CQRS | 高 | 中 | 高 | 读写分离 |
| 断路器 | 低 | 高 | 高 | 外部依赖 |
