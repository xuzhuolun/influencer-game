---
description: "[L3-Project] 错误做法反例集合 - PDCA 错题集驱动规则进化"
globs:
  - "**/*.h"
  - "**/*.cpp"
  - "**/*.md"
alwaysApply: true
tags: project, badcase, pdca
level: L3
scope: template
---

# [L3-Project] 错误做法反例集合

> **层级**: L3 (项目特定规则)
> **类型**: `pdca` | **目的**: 错题集驱动规则进化 (Human Error → New Rule)
> **适用范围**: `template` - 各项目按需填充具体案例

本文档记录开发过程中遇到的错误做法，作为反例参考，避免重复犯错。

---

## 📝 如何添加新的反例

当遇到错误做法时，按以下格式添加：

```markdown
## ❌ 反例 N：简短描述
> **状态**: `[ ] 待转化`

### 问题场景
描述遇到的具体问题

### 错误做法
展示错误的代码示例

### 为什么错误？
列出错误的原因

### 正确做法
展示正确的代码示例

### 关键原则
总结关键原则
```

### 状态说明
- `[ ] 待转化` - 尚未形成规则
- `[x] 已转化` - 已升级为 L1/L2 规则（标注目标规则）

---

## 反例模板示例

### ❌ 反例 X：使用 Tick 持续检查来"修复"单次调用失效的问题
> **状态**: `[x] 已转化` → 见 L1-ue5-core-standards.mdc (Tick 优化)

#### 问题场景
**需求**：某个状态变化时需要执行一次性操作（如禁用移动）

#### 错误做法
```cpp
// ❌ 错误：在 Tick 中持续检查并执行
void UMyComponent::TickComponent(float DeltaTime, ...)
{
    CheckAndEnforceState();  // 每帧都执行
}
```

#### 为什么错误？
1. **性能浪费**：每帧都执行检查
2. **掩盖问题**：真正的问题没有被解决
3. **不可维护**：Tick 检查会持续对抗其他逻辑
4. **设计不合理**：Tick 不应该用来"修复"问题

#### 正确做法
```cpp
// ✅ 正确：延迟一帧执行
World->GetTimerManager().SetTimerForNextTick([this]()
{
    ExecuteOneTimeAction();
});
```

#### 关键原则
1. **找到根本原因**：不用 Tick 持续修复
2. **时机很重要**：在正确的时机调用
3. **延迟执行**：使用 `SetTimerForNextTick`

#### 判断标准

**什么时候可以用 Tick？**
- ✅ 状态需要持续更新（如数值递减）
- ✅ 需要持续监听变化（如范围检测）

**什么时候不应该用 Tick？**
- ❌ 用来"修复"单次调用失效的问题
- ❌ 用来对抗其他逻辑
- ❌ 用来掩盖设计问题

---

## 项目特定反例

> 以下为各项目收集的具体反例，按需填充

（在此添加项目特定的反例...）

---

**层级**: L3-Project | **最后更新**: 2026年2月
