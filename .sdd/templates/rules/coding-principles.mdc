---
alwaysApply: true
---

# 核心编码原则 (10X 开发者)

这些原则适用于所有代码，无论使用何种语言或框架。遵循它们以编写可维护、可扩展和高效的代码。

## DRY（不要重复自己）

**原则:** 系统中的每一项知识都必须有一个单一、明确的表示。

**规则:**
- **提取公共逻辑:** 如果你写了两次相同的代码，就提取到函数/组件中
- **重用组件:** 不要复制 UI 组件 - 创建可重用的组件
- **集中配置:** 将常量、配置和设置存储在一个地方
- **避免复制粘贴:** 重构而不是复制代码块
- **创建工具函数:** 为重复操作构建工具函数

**示例:**
```javascript
// ❌ 错误: 重复的逻辑
function calculateTotal(items) {
  let total = 0;
  for (let item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

function calculateSubtotal(items) {
  let total = 0;
  for (let item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// ✅ 正确: 提取公共逻辑
function calculateItemTotal(item) {
  return item.price * item.quantity;
}

function calculateTotal(items) {
  return items.reduce((sum, item) => sum + calculateItemTotal(item), 0);
}

function calculateSubtotal(items) {
  return calculateTotal(items); // 重用
}
```

**何时提取:**
- 代码出现 3+ 次 → 提取到函数
- 类似逻辑有细微变化 → 使用参数
- 重复模式 → 创建抽象

---

## KISS（保持简单）

**原则:** 简洁性应该是设计的关键目标，应避免不必要的复杂性。

**规则:**
- **优先简单解决方案:** 选择有效的最简单解决方案
- **避免过度工程:** 不要添加"以防万一"的复杂性
- **清晰胜于聪明:** 编写易于理解的代码
- **最小抽象:** 只有在提供明确价值时才进行抽象
- **可读性优先:** 代码被阅读的次数比被编写的次数多 - 优先考虑可读性

**示例:**
```javascript
// ❌ 错误: 过度工程
class AbstractFactoryPattern {
  createStrategy(type) {
    const strategies = {
      simple: new SimpleStrategyFactory(),
      complex: new ComplexStrategyFactory()
    };
    return strategies[type]?.create();
  }
}

// ✅ 正确: 简单明了
function calculate(operation, a, b) {
  if (operation === 'add') return a + b;
  if (operation === 'subtract') return a - b;
  if (operation === 'multiply') return a * b;
  return a / b;
}
```

**复杂度指南:**
- 初级开发者能理解吗？→ 好
- 需要深度框架知识？→ 简化
- 嵌套超过 3 层？→ 重构
- 函数超过 50 行？→ 拆分

---

## 模块化设计

**原则:** 将代码分解为独立、可重用的模块，具有清晰的职责。

### 单一职责原则 (SRP)

**规则:**
- **一个变更理由:** 每个模块应该只有一个变更的理由
- **明确用途:** 函数/组件应该做好一件事
- **专注的模块:** 保持模块专注于单一关注点

**示例:**
```javascript
// ❌ 错误: 多个职责
class User {
  save() { /* 数据库逻辑 */ }
  sendEmail() { /* 邮件逻辑 */ }
  validate() { /* 验证逻辑 */ }
  formatDisplay() { /* 格式化逻辑 */ }
}

// ✅ 正确: 单一职责
class User {
  validate() { /* 仅验证 */ }
}

class UserRepository {
  save(user) { /* 仅数据库 */ }
}

class EmailService {
  send(user) { /* 仅邮件 */ }
}

class UserFormatter {
  format(user) { /* 仅格式化 */ }
}
```

### 关注点分离

**规则:**
- **分层:** 分离数据、业务逻辑和表示层
- **独立性:** 模块应独立工作
- **清晰边界:** 定义模块间清晰的接口
- **无交叉:** 避免混合关注点

**层级:**
- **数据层:** 数据库、API、存储
- **业务层:** 逻辑、规则、计算
- **表示层:** UI、格式化、显示
- **基础设施:** 日志、监控、配置

### 松耦合

**规则:**
- **依赖接口:** 而非具体实现
- **最小依赖:** 依赖越少 = 变更越容易
- **依赖注入:** 传递依赖，而非创建它们
- **事件驱动:** 尽可能使用事件进行通信

**示例:**
```javascript
// ❌ 错误: 紧耦合
class OrderService {
  constructor() {
    this.emailService = new EmailService(); // 紧耦合
  }
}

// ✅ 正确: 松耦合
class OrderService {
  constructor(emailService) { // 依赖注入
    this.emailService = emailService;
  }
}
```

### 高内聚

**规则:**
- **相关功能放在一起:** 将相关函数分组
- **逻辑分组:** 模块中的函数应该协同工作
- **明确模块用途:** 每个模块都有清晰、专注的用途

---

## SOLID 原则

### 单一职责原则
- 每个类/函数应该只有一个变更的理由
- 每个模块一个职责

### 开闭原则
- 对扩展开放，对修改关闭
- 使用继承/组合而不是修改

### 里氏替换原则
- 子类型必须可以替换其基类型
- 派生类不能破坏基类契约

### 接口隔离原则
- 客户端不应依赖它们不使用的接口
- 创建特定接口，而非大型通用接口

### 依赖倒置原则
- 依赖抽象，而非具体
- 高级模块不应依赖低级模块

---

## 清洁代码原则

### 有意义的命名
- **描述性:** 名称应揭示意图
- **可发音:** 使用单词，而非缩写
- **可搜索:** 避免单字母名称
- **一致性:** 对相同概念使用相同词汇

### 函数
- **小:** 函数应该小
- **做一件事:** 单一职责
- **描述性名称:** 函数名描述它做什么
- **少量参数:** 0-2 个参数理想，3+ 个考虑使用对象
- **无副作用:** 函数应该只做名称所说的事

### 注释
- **解释为什么:** 而非是什么（代码解释是什么）
- **阐明意图:** 当代码无法自解释时
- **避免冗余:** 不要重复代码说的内容
- **保持更新:** 过时的注释比没有注释更糟糕

### 错误处理
- **快速失败:** 尽早检测错误
- **不要忽略:** 始终处理错误
- **提供上下文:** 错误消息应该有帮助
- **使用异常:** 不要返回错误代码

### 格式化
- **一致:** 遵循项目风格指南
- **垂直密度:** 相关代码放在一起
- **水平距离:** 相关代码水平靠近
- **团队标准:** 使用团队的格式化规则

---

## 代码组织

### 文件结构
- **逻辑分组:** 将相关文件分组
- **清晰层级:** 优先扁平结构（最多 3-4 层）
- **一致命名:** 遵循命名约定
- **分离:** 适当时按功能/领域分离

### 导入/导出
- **显式:** 使用显式导入/导出
- **有组织:** 逻辑分组导入
- **最小化:** 只导入需要的
- **一致:** 遵循项目导入风格

### 依赖项
- **最小化:** 保持依赖项最少
- **保持更新:** 保持依赖项更新
- **安全:** 检查漏洞
- **文档化:** 记录为什么需要依赖项

---

## 性能考虑

### 效率
- **需要时优化:** 不要过早优化，但在需要时优化
- **先测量:** 优化前先分析
- **算法选择:** 选择适当的算法
- **资源使用:** 注意内存、CPU、网络

### 可扩展性
- **为规模设计:** 从一开始就考虑增长
- **避免瓶颈:** 识别并解决瓶颈
- **缓存:** 适当使用缓存
- **延迟加载:** 需要时再加载资源

---

## 安全原则

### 输入验证
- **验证所有输入:** 永远不要信任用户输入
- **清理:** 使用前清理输入
- **类型检查:** 验证类型
- **边界检查:** 检查范围和限制

### 身份验证和授权
- **安全认证:** 使用经过验证的认证方法
- **最小权限:** 授予最少必要的权限
- **会话管理:** 安全的会话处理
- **令牌安全:** 安全的令牌存储和传输

### 数据保护
- **加密敏感数据:** 静态和传输中加密
- **代码中无密钥:** 使用环境变量
- **安全存储:** 保护数据库凭据
- **HTTPS:** 生产环境始终使用 HTTPS

---

## 测试原则

### 测试覆盖率
- **测试关键路径:** 测试重要功能
- **测试边界情况:** 测试边界和错误
- **测试集成:** 测试组件交互
- **维护测试:** 随代码更新测试

### 测试质量
- **快速:** 测试应该快速运行
- **独立:** 测试不应相互依赖
- **可重复:** 测试应产生相同结果
- **自验证:** 测试应明确通过或失败

---

## 文档原则

### 代码文档
- **自文档化:** 代码应该自我解释
- **需要时注释:** 注释复杂逻辑
- **API 文档:** 记录公共 API
- **示例:** 包含使用示例

### 项目文档
- **README:** 清晰的项目概述
- **设置指南:** 如何开始
- **架构:** 系统设计文档
- **变更日志:** 跟踪随时间的变化

---

## 版本控制

### 提交信息
- **描述性:** 清楚说明更改了什么以及为什么
- **约定式:** 遵循约定式提交
- **原子性:** 每次提交一个逻辑更改
- **引用问题:** 链接到问题/工单

### 分支
- **清晰命名:** 使用一致的分支名称
- **功能分支:** 每个分支一个功能
- **保持更新:** 定期合并 main/master
- **清洁历史:** 保持提交历史整洁

---

## 总结

**始终记住:**
1. **DRY** - 不要重复自己
2. **KISS** - 保持简单
3. **模块化** - 单一职责，关注点分离
4. **清洁** - 可读、可维护的代码
5. **安全** - 设计时考虑安全
6. **测试** - 测试你的代码
7. **文档** - 需要时编写文档

**将这些原则应用于:**
- 函数设计
- 组件结构
- 模块组织
- 系统架构
- 团队协作

---

**生成者:** `/generate-rules` 命令  
**最后更新:** {{DATE}}  
**项目复杂度:** {{COMPLEXITY}}